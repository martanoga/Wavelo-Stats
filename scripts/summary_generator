#!/usr/bin/env python3

import argparse
from datetime import datetime, tzinfo, timezone
import metar
from metar import Metar
import re
import time
import urllib.request
import yaml
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader, Dumper

from collections import Counter

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--data', nargs='+', default=['wavelo_data.yaml'], type=str, help='data file name', dest='data_fnames')
parser.add_argument('-f', '--from', nargs=1, default=None, type=str, help='start time (localtime, YYYY-mm-dd HH:MM:SS)', dest='t0')
parser.add_argument('-t', '--to', nargs=1, default=None, type=str, help='end time (localtime, YYYY-mm-dd HH:MM:SS)', dest='t1')
args = parser.parse_args()

raw_data = {}

for data_fname in args.data_fnames:
    with open(data_fname, 'r') as data_file:
        raw_data.update(yaml.load(data_file, Loader=Loader))

for k in sorted(raw_data.keys()):
    if 'bikes' not in raw_data[k]:
        del raw_data[k]
    
t0 = args.t0 
if t0 == None:
    t0 = sorted(raw_data.keys())[0]
else:
    t0 = t0[0]

t1 = args.t1
if t1 == None:
    t1 = sorted(raw_data.keys())[-1]
else:
    t1 = t1[0]

t0 = int(time.mktime(datetime.strptime(t0, "%Y-%m-%d %H:%M:%S").timetuple()))
t1 = int(time.mktime(datetime.strptime(t1, "%Y-%m-%d %H:%M:%S").timetuple()))

utc0 = datetime.utcfromtimestamp(t0).utctimetuple()
utc1 = datetime.utcfromtimestamp(t1).utctimetuple()

metars = {}
with urllib.request.urlopen('http://www.ogimet.com/display_metars2.php?lang=en&lugar=EPKK&tipo=SA&ord=REV&nil=NO&fmt=txt&ano=%d&mes=%d&day=%d&hora=%d&min=%d&anof=%d&mesf=%d&dayf=%d&horaf=%d&minf=%d&send=send' % (utc0.tm_year, utc0.tm_mon, utc0.tm_mday, utc0.tm_hour, utc0.tm_min, utc1.tm_year, utc1.tm_mon, utc1.tm_mday, utc1.tm_hour, utc1.tm_min)) as f:
    data = f.read().decode('utf-8').replace('\n', ' ')
    for m in re.finditer('METAR EPKK[^=]+', data):
        metar = Metar.Metar(m.group(0))
        metar.time = metar.time.replace(tzinfo=timezone.utc)
        metars[metar.time.astimezone().strftime('%Y-%m-%d %H:%M:%S')] = metar

hubs_data = {}
bikes_data = {}
hubs = {}
bikes = {}

prev_ts = None
max_dt = None

for k in sorted(raw_data.keys()):
    ts = raw_data[k]['timestamp']
    if ts < t0 or ts > t1:
        continue

    h = raw_data[k]['hubs']
    hubs_data[ts] = h
    for hk in h.keys():
        if not hk in hubs:
            hubs[hk] = {'id': h[hk]['id'], 'name': h[hk]['name'], 'rentals': 0, 'returns': 0}
    b = raw_data[k]['bikes']
    bikes_data[ts] = b
    for bk in b.keys():
        if not bk in bikes:
            bikes[bk] = {'id': b[bk]['id'], 'name': b[bk]['name'], 'rentals': 0, 'returns': 0}

    if not prev_ts is None:
        dt = ts - prev_ts
        if max_dt is None:
            max_dt = dt
        if dt > max_dt:
            max_dt = dt

    prev_ts = ts

hubs[None] = {'id': None, 'name': 'out_of_station', 'rentals': 0, 'returns': 0}

del raw_data

rented = {}
trips = Counter()
rental_times = []

res = {
    't0': datetime.fromtimestamp(t0).strftime('%Y-%m-%d %H:%M:%S'),
    't1': datetime.fromtimestamp(t1).strftime('%Y-%m-%d %H:%M:%S'),
    'meteo': {},
    'total_time': t1 - t0,
    'max_dt': max_dt,
    'bikes_accounted_for': len(bikes),
    'total_rentals': 0,
    'total_returns': 0
    }

for d in metars:
    metar = metars[d]
    res['meteo'][d] = { 'metar': metar.code, 'temp': metar.temp.value('C'), 'dewpt': metar.dewpt.value('C'), 'wind_speed': metar.wind_speed.value('KMH'), 'vis': metar.vis.value('M') }
    if metar.weather:
        res['meteo'][d]['weather'] = metar.present_weather()
    
pb = bikes_data[sorted(bikes_data.keys())[0]]
for ts in sorted(bikes_data.keys()):
    b = bikes_data[ts]

    for bk in pb.keys():
        if (not bk in b) or (bk in b and pb[bk]['hub_id'] != b[bk]['hub_id']):
            hubs[pb[bk]['hub_id']]['rentals'] += 1
            rented[bk] = { 'from': pb[bk]['hub_id'], 'timestamp': ts }
            res['total_rentals'] += 1

    for bk in b.keys():
        if (not bk in pb) or (bk in pb and b[bk]['hub_id'] != pb[bk]['hub_id']):
            hubs[b[bk]['hub_id']]['returns'] += 1
            if bk in rented:
                trips[(rented[bk]['from'], b[bk]['hub_id'])] += 1
                rental_times.append(ts - rented[bk]['timestamp'])
                del rented[bk]
            res['total_returns'] += 1

    pb = b

res['hubs'] = hubs
res['trips'] = []

for t in trips.most_common():
    res['trips'].append({'from': t[0][0], 'to': t[0][1], 'count': t[1]})

res['complete_rentals'] = len(rental_times)
res['spurious_rentals'] = sum(t == 0 for t in rental_times)
rental_times = [t for t in rental_times if t != 0]
res['short_rentals'] = sum(t <= 1200 for t in rental_times)
res['medium_rentals'] = sum(t > 1200 and t <=3600 for t in rental_times)
res['long_rentals'] = sum(t > 3600 for t in rental_times)
res['xlong_rentals'] = sum(t > 5400 for t in rental_times)
res['shortest_rental'] = min(rental_times)
res['longest_rental'] = max(rental_times)
res['average_rental'] = sum(rental_times) / float(len(rental_times))

print(yaml.dump(res, allow_unicode = True, default_flow_style = False))
